@startuml

state MqttClient {

    state Disconnected
    [*] --> Disconnected
    Disconnected : DISCONNECT_REQ / ^DISCONNECT_RSP(success)

    state Connecting
    Connecting : entry/ start timeoutTimer; mqtt_pal_connect_start();
    Connecting : exit/ stop timeoutTimer;

    state Disconnecting
    Disconnecting: entry/ start timeoutTimer; mqtt_pal_disconnect_start();
    Disconnecting: exit/ stop timeoutTimer;

    state CriticalError
    CriticalError: entry/ assert(); system_reset();

    Disconnected -> Connecting : CONNECT_REQ
    Connecting --> Connected : ON_MQTT_PAL_CONNECTED / ^MQTT_CONNECTED
    Connecting --> Disconnected : TIMEOUT, FAILED / ^MQTT_DISCONNECTED(error)
    Disconnecting --> Disconnected : ON_MQTT_PAL_DISCONNECTED / ^DISCONNECT_RSP(success)
    Connected -> Disconnecting : DISCONNECT_REQ
    Connected --> Disconnected : ON_MQTT_PAL_DISCONNECTED, FAILED, TIMEOUT / ^MQTT_DISCONNECTED(error)
    Disconnecting --> CriticalError : TIMEOUT, FAILED

    ' Note: the following state machine definition does not support MQTT send pipeline 
    ' (i.e. sending PUB SUB without waiting for the respective ACKs).
    state Connected {
        Connected : ON_MQTT_PAL_RECV/ ^MQTT_RECV_IND(message)

        state Idle
        Idle : entry/ recall;

        state PUB_Sending
        PUB_Sending : entry/ start timeoutTimer; mqtt_pal_pub_start()
        PUB_Sending : exit/ stop timeoutTimer;
        PUB_Sending : MQTT_PUB_REQ, MQTT_SUB_REQ/ defer;
        PUB_Sending : ON_MQTT_PAL_PUB_ACK/ ^^SENT

        state SUB_Sending
        SUB_Sending : entry/ start timeoutTimer; mqtt_pal_sub_start()
        SUB_Sending : exit/ stop timeoutTimer;
        SUB_Sending : MQTT_PUB_REQ, MQTT_SUB_REQ/ defer;
        SUB_Sending : ON_MQTT_PAL_SUB_ACK/ ^^SENT

        [*] -> Idle

        Idle --> PUB_Sending : MQTT_PUB_REQ
        Idle --> SUB_Sending : MQTT_SUB_REQ
        PUB_Sending -> Idle : SENT / ^MQTT_PUB_RSP(success)
        SUB_Sending -> Idle : SENT/ ^MQTT_SUB_RSP(success)
    }
}

@enduml
